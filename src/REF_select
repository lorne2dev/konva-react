import Konva from 'konva';
import React from 'react';
import { Stage, Layer, Rect } from 'react-konva';
import ContextMenu from './ContextMenu';

const MOUSEONE = 0;
const MOUSETWO = 2;
const MOUSETHREE = 1;

class RegionSelect extends React.Component {
  constructor(props) {
    super(props);
    this.stage = React.createRef();
    this.state = {
      grabDown: false,
      grab: false,
      quickPan: false,
      boxes: props.boxes,
      stageOffset: {
        x: 0,
        y: 0,
      },
      selection: {
        visible: false,
        x1: null,
        y1: null,
        x2: null,
        y2: null,
      },
      contextMenu: {
        visible: false,
        x: null,
        y: null,
      },
    };
  }

  calculateOffset = (x, y) => {
    return { x: x - this.state.stageOffset.x, y: y - this.state.stageOffset.y };
  };

  deselectAllBoxes = () => {
    this.setState({
      boxes: this.state.boxes.map((box) => {
        return { ...box, selected: false };
      }),
    });
  };

  getSelected = () => {
    return this.state.boxes.filter((box) => box.selected);
  };

  selectBoxes = (ids) => {
    this.setState((state) => {
      return {
        boxes: state.boxes.map((box) => {
          if (ids.includes(box.id)) {
            return { ...box, selected: true };
          } else {
            return box;
          }
        }),
      };
    });
  };

  updateSelectionPosition = (selection, coords) => {
    const { x, y } = this.calculateOffset(coords.x, coords.y);
    return { selection, x2: x, y2: y };
  };

  mergeBoxesById = (entry, modified) => {
    return entry.map((obj) => modified.find((o) => o.id === obj.id) || obj);
  };

  generateSelectionBox = () => {
    return {
      x: Math.min(this.state.selection.x1, this.state.selection.x2),
      y: Math.min(this.state.selection.y1, this.state.selection.y2),
      height: Math.abs(this.state.selection.y2 - this.state.selection.y1),
      width: Math.abs(this.state.selection.x2 - this.state.selection.x1),
    };
  };

  onStageDrag = (e) => {
    if (this.state.grab) {
      this.setState({
        stageOffset: {
          x: e.target.x(),
          y: e.target.y(),
        },
      });
    }
  };

  onStageDragEnd = (e) => {
    if (this.state.quickPan) {
      this.setState({ grab: false });
    }
  };

  getBoxById = (id) => {
    return this.state.boxes.find((box) => {
      return box.id === id;
    });
  };

  hideContextMenu = () => {
    this.setState((state) => {
      return { contextMenu: { ...state.contextMenu, visible: false } };
    });
  };

  mouseDown = (e) => {
    const stage = this.stage.current;
    const { target } = e;

    if (e.evt.button === MOUSEONE || e.evt.button === MOUSETWO) {
      if (target.name() === 'rect') {
        const box = this.getBoxById(target.id());
        if (!!!box.selected) {
          this.deselectAllBoxes();
          this.selectBoxes([box.id]);
        }
      } else {
        this.hideContextMenu();
      }

      if (e.evt.button === MOUSEONE) {
        if (this.state.grab) {
          this.setState({ grabDown: true });
        } else {
          this.hideContextMenu();
          if (e.target === stage) {
            this.setState((state) => {
              const { x, y } = this.calculateOffset(
                stage.getPointerPosition().x,
                stage.getPointerPosition().y
              );
              return {
                selection: {
                  ...state.selection,
                  visible: true,
                  x1: x,
                  y1: y,
                  x2: x,
                  y2: y,
                },
              };
            });
          }
        }
      }
    }
    if (e.evt.button === MOUSETHREE) {
      e.evt.preventDefault();
      this.setState({ grab: true, quickPan: true, grabDown: true });
    }
  };

  mouseMove = (e) => {
    const stage = this.stage.current;
    if (!!!this.state.selection.visible) {
      return;
    }

    this.setState((state) => {
      const { x, y } = this.calculateOffset(
        stage.getPointerPosition().x,
        stage.getPointerPosition().y
      );
      return {
        selection: {
          ...state.selection,
          x2: x,
          y2: y,
        },
      };
    });
  };

  mouseUp = (e) => {
    if (this.state.grab) {
      this.setState({ grabDown: false });

      if (this.state.quickPan) {
        this.setState({ grab: false, quickPan: false });
      }
    }

    if (this.state.selection.visible) {
      this.setState({
        selection: {
          ...this.state.selection,
          visible: false,
        },
      });

      const selectionBox = this.generateSelectionBox();
      const selected = this.state.boxes.filter((shape) => {
        return Konva.Util.haveIntersection(selectionBox, shape);
      });
      this.deselectAllBoxes();
      this.selectBoxes(selected.map((a) => a.id));
    }
  };

  onClick = (e) => {};

  onDragStart = (e) => {
    const { target } = e;
    const box = this.getBoxById(target.id());

    // If target box isn't selected. Deselect all Boxes and only select target.
    if (!!!box.selected) {
      this.deselectAllBoxes();
      this.selectBoxes([box.id]);
    }
  };

  moveSelectedBoxes = (x, y) => {
    this.setState((state) => {
      return {
        boxes: state.boxes.map((box) => {
          if (box.selected) {
            return {
              ...box,
              x: box.x + x,
              y: box.y + y,
            };
          } else {
            return box;
          }
        }),
      };
    });
  };

  onDragMove = (e) => {
    const { target } = e;
    const box = this.getBoxById(target.id());
    const movement = {
      x: target.x() - box.x,
      y: target.y() - box.y,
    };
    this.moveSelectedBoxes(movement.x, movement.y);
  };

  onBoxDragEnd = (e) => {
    const selected = this.getSelected();
    console.log(selected);
  };

  onContextMenu = (e) => {
    e.evt.preventDefault();
    const stage = this.stage.current;
    const { target } = e;
    if (target === this.stage.current) {
      this.deselectAllBoxes();
    }
    const coordinates = this.calculateOffset(
      stage.getPointerPosition().x,
      stage.getPointerPosition().y
    );

    this.setState((state) => {
      return {
        contextMenu: {
          ...state.contextMenu,
          x: coordinates.x,
          y: coordinates.y,
          visible: true,
        },
        grab: false,
      };
    });
  };

  createBox = () => {
    this.hideContextMenu();
    this.setState((state) => {
      return {
        boxes: [
          ...state.boxes,
          {
            id: String(Math.random() * 100000000),
            x: state.contextMenu.x,
            y: state.contextMenu.y,
            height: 10,
            width: 10,
            fill: ['blue', 'red', 'green'][Math.floor(Math.random() * 3)],
            selected: false,
          },
        ],
      };
    });
  };

  deleteBoxes = () => {
    this.hideContextMenu();
    const selected = this.getSelected();
    this.setState((state) => {
      return {
        boxes: state.boxes.filter((box) => !!!box.selected),
      };
    });
  };

  generateContextOptions = () => {
    let returnValue = [{ name: 'Create', func: this.createBox }];
    if (
      this.state.boxes.some((box) => {
        return box.selected;
      })
    ) {
      returnValue.push({ name: 'Delete', func: this.deleteBoxes });
    }

    return returnValue;
  };

  handleKeyPress = (e) => {
    if (e.key === 'g') {
      this.setState((state) => {
        return {
          quickPan: false,
          grab: !state.grab,
          selection: { ...state.selection, visible: false },
        };
      });
    }
  };

  handleKeyUp = (e) => {};

  selectCursor = () => {
    if (this.state.grab) {
      if (this.state.grabDown) {
        return 'grabbing';
      } else {
        return 'grab';
      }
    } else {
      return '';
    }
  };

  render() {
    const StageStyle = {
      backgroundColor: '#e5e5f7',
      opacity: 0.8,
      backgroundImage: 'radial-gradient(#444cf7 1.1px, #e5e5f7 1.1px)',
      backgroundSize: '22px 22px',
      backgroundPosition:
        this.state.stageOffset.x + 'px ' + this.state.stageOffset.y + 'px',
    };

    return (
      <div
        onKeyDown={this.handleKeyPress}
        onKeyUp={this.handleKeyUp}
        tabIndex="0"
        className={this.selectCursor()}
      >
        <Stage
          width={window.innerWidth}
          height={window.innerHeight}
          onMouseDown={this.mouseDown}
          onMouseMove={this.mouseMove}
          onMouseUp={this.mouseUp}
          ref={this.stage}
          onContextMenu={this.onContextMenu}
          onClick={this.onClick}
          draggable={this.state.grab}
          onDragMove={this.onStageDrag}
          onDragEnd={this.onStageDragEnd}
          style={StageStyle}
        >
          <Layer>
            {this.state.boxes.map((box) => (
              <Rect
                key={box.id}
                id={box.id}
                x={box.x}
                y={box.y}
                width={box.width}
                height={box.height}
                fill={box.selected ? 'yellow' : box.fill}
                name="rect"
                draggable={!this.state.grab}
                onDragStart={this.onDragStart}
                onDragMove={this.onDragMove}
                onDragEnd={this.onBoxDragEnd}
              />
            ))}
            {this.state.selection.visible && (
              <Rect
                name="selection"
                x={Math.min(this.state.selection.x1, this.state.selection.x2)}
                y={Math.min(this.state.selection.y1, this.state.selection.y2)}
                height={Math.abs(
                  this.state.selection.y2 - this.state.selection.y1
                )}
                width={Math.abs(
                  this.state.selection.x2 - this.state.selection.x1
                )}
                fill="teal"
                opacity={0.8}
                strokeWidth={1}
                stroke="blue"
              />
            )}

            {this.state.contextMenu.visible && (
              <ContextMenu
                x={this.state.contextMenu.x}
                y={this.state.contextMenu.y}
                options={this.generateContextOptions()}
              />
            )}
          </Layer>
        </Stage>
      </div>
    );
  }
}

export default RegionSelect;
